Operating System (운영체제)
==========
## 프로세스
* **프로그램**  
  보조 기억장치(하드디스크, SSD)에 존재하며 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음  
-> 생명이 존재하지 않음

* **프로세스**  
실행 중인 프로그램  
-> 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 생명이 생김  

> Q.프로세스를 여러 개 실행 시킬 수 있을까?

컴퓨터의 세상에서 여러 개의 프로세스가 동시에 실행되는 건 놀라운 일!  
-> 하나의 CPU 즉, 프로세서는 한 순간에 하나의 프로세스만 실행 가능

> Q.그럼 어떻게 여러 개의 프로세스가 동시에 실행 가능할까?

사실은 여러 개의 프로세스가 실행되고 있는 것이 아니라  
운영체제가 엄청나게 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문에  
동시에 실행되고 있다라고 느끼는 것일뿐 하나의 프로세스만 실행되고 있음!


## 프로세스의 구성
> 프로세스에 대한 정보는 프로세스 제어블록(PCB, Process Control Block)또는 
프로세스 기술자(process descriptor)라고 부르는 자료구조에 저장됨
대부분 PCB라고 부름
이 자료구조는 크게 다음 같은 정보를 담고 있다

* **PID (Process IDentification)**   
```
운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호
```

* **프로세스 상태**  
```
CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에  
실행 중인 프로세스도 있고 대기 중인 프로세스도 있음  
이런 프로세스 상태 말하고 이 정보를 저장하고 있음
```

* **프로그램 카운터**  
```
CPU가 다음으로 실행할 명령어를 가리키는 값  
CPU는 기계어를 한 단위씩 읽어서 처리  
프로세스를 실행하기 위해 다음으로 실행할 기계어가 
저장된 메모리 주소를 가리키는 값
```

* **스케줄링과 스케줄링 우선순위**  
```
스케줄링이란 운영체제가 여러개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것  
이 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 함
```

* **권한**
```
프로세스가 접근할 수 있는 자원을 결정하는 정보

ex)  
아무 앱이나 휴대폰 통화내역을 볼 수 있는 권한을 가짐   
-> 이를 악의적으로 이용하는 앱 등장
그렇기 때문에 프로세스마다 어디까지 접근할 수 있는지에 대한 권한이 필요
```

* **프로세스의 부모와 자식 프로세스**
```
최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성됨
이 계층관계는 트리를 형성
그래서 각 프로세스는 자식 프로세스와 부모 프로세스에 대한 정보를 가지고 있음
```

* **프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터**
```
프로세스는 실행 중인 프로그램이기 때문에 프로그램에 대한 정보를 가지고 있음
프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장됨
이 공간에 대한 값입 바로 포인터 값 
```

* **프로세스에 할당된 자원들을 가리키는 포인터**
```
```

* **실행문맥**
```
프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고 있음
CPU에서 실행되는 프로세스는 운영체제에 의해 계속 교체되는데 교체되었다가 다시 자신의 차례가 되어서 실행될 때
중단된 적 없고 마치 연속적으로 실행된 것처럼 하기 위해 이 레지스터 정보를 가지고 있음
```

> 이것들이 왜 프로세스에게 없어서는 안될 요소인지 생각해보자

## 프로세스가 접근할 수 있는 메모리 공간
> Q.프로세스의 데이터와 명령어가 있는 메모리는 어떻게 구성되어 있을까?  

### 들어가기 전에 이것만은 꼭...
1.
데이터나 프로그램을 저장하는 저장 공간은 계층 구조를 가짐
CPU에서 가장 가까운 저장 공간 is 레지스터
레지스터 -> CPU 캐시 메모리 -> 메인 메모리 -> 보조기억장치 -> 외부기억장치 
순으로 CPU와 멀어짐
CPU로부터 멀어질수록 데이터를 저장하는 용량이 커지고 접근 속도는 느려짐

2.
ROM은 read only
RAM은 read/write

3. 
프로그램 작성 -> 작성한 프로그램을 디스크에 저장 -> 사용자가 운영체제에 프로그램의 실행을 요청 -> 운영체제가 프로그램의 정보를 읽어 메인 메모리에 공간을 할당에 load

스택 영역과 힙 영역 사이에 빈 공간 
컴파일 타임에 지역변수를 얼마나 사용할지 미리 계산할 수 없기 때문에 런타임에 지역변수 선언 순서에 따라 
-> 스택영역은 위쪽으로 주소 값을 매기고
-> 동적 할당될 때 힙 영역은 아래쪽으로 주소 값을 매김

![memory](https://images.velog.io/images/goserimgoserimgo/post/5e3e1d1f-94d8-4e09-b55f-620ebb00c071/_2020-08-02__10.36.08.png)
### Code 영역 (Text 영역)  
* 사용자가 작성한 코드가 저장되는 영역  
즉, 실행할 프로그램의 코드가 저장되어 있는 영역  
 -> 이 코드는 컴파일된 후 기계어 형태로 저장되어 있음    
 -> 이렇게 컴퓨터에게 일을 시키는 실행코드를 Instruction이라고 함  
 -> CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리함  
 * 프로그램이 실행되고 끝날 때까지 메모리에 남아있음  
 * 읽기 전용  
 * 다른 프로세스에서 참조 가능한 영역 <- ???  
 
 ### Data 영역  
 * 프로그램의 전역 변수와 static 변수 등이 저장되어 있는 영역  
 * 프로그램 실행 시, 전역 변수와 static 변수는 메인 함수가 호출되기 전에 데이터 영역에 할당됨  
 * 프로그램이 실행되고 끝날 때까지 메모리에 남아있음  
   - BSS(Block Stated Symbol) 영역  
   - Data 영역   
     + 초기화가 이루어진 변수들이 저장됨  
     + 프로그램 실행 중 자유롭게 접근해서 수정, 변경이 가능  
     + 사실 데이터 영역은 ROM에 위치하는데 전역변수와 static 변수를 ROM에  
       저장하면 런타임 시 변경된 값을 저장할 수 있도록 한다고 함  
       
     Wyh?   
      ROM은 뭐다> read only다.   
    
   > BSS와 Data 영역을 나누는 이유는?  
   
   초기화된 데이터는 ROM의 data 영역에 저장됨  
   하지만 아직 초기화 되지 않은 데이터들까지 ROM에 저장되지 않은 데이터들까지 ROM에 저장되면  
   큰 사이즈의 ROM이 필요하기 때문에 이 영역을 나눈다고 함  
   
### Heap 영역  
 * 프로그램이 실행되는 동안 동적으로 사용할 데이터가 저장됨  
 * 사용자가 직적 관리하는 영역  
   -> 즉, 사용자에 의해 메모리가 동적으로 할당, 해제됨  
 * class, closure와 같은 참조 타입의 데이터가 저장됨  
  - swift의 경우 ARC가 참조 타입의 할당, 해제 해줘야 함  
  - Java의 경우 가비지 콜렉터가 관리함  
  - C의 경우 사용자가 동적으로 할당, 해제 해줘야 함 (malloc, free?)  
 * 메모리의 낮은 주소 -> 높은 주소로 할당  
 * 런타임 시 (= 프로그램이 실행되는 도중)에 힙 영역의 크기가 결정됨  
 
 ### Stack 영역  
  * 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장됨  
  * 즉, 함수 호출 시 할당되며 실행이 끝나면 메모리에 해제됨  
    - 프로그램이 사용하는 임시 메모리 영역 정도로 생각  
    - 함수 호출 시 스택에 push 되고, return을 하면 스택에서 pop  
    - 할당과 해제를 반복하기 때문에 데이터의 용량이 불확실함  
    - 이렇게 스택 영역에 저장된 함수 호출 정보를 Stack Frame이라고 함  
  * struct, enum과 같은 값 타입의 데이터가 저장됨  
  * 메모리의 높은 주소 -> 낮은 주소로 할당됨  
  
    > Q.왜 이렇게 할당하지??  
    
     스택 영역과 힙 영역 사이에 빈 공간
     컴파일 타임에 지역변수를 얼마나 사용할 지 미리 계산할 수 없기 때문에
     런타임에 지역변수 선언 순서에 따라 스택영역은 위쪽으로 주소 값을 매기고
     동적 할당될 때 힙 영역은 아래쪽으로 주소값을 매김
  * 컴파일 시에 할당될 영역의 크기가 결정됨  
  * 운영체제에 따라 제한된 스택 영역의 크기가 다름  
  -> 이 크기를 초과해 push할 수 없음!  
  
  ### Stack 영역 vs Heap 영역  
   * 스택 영역과 힙 영역은 사실상 같은 공간을 사용한다  
   그래서 스택 영역이 클수록 힙 영역이 작아지고 힙 영역이 클수록 스택 영역이 작아진다  
   
   * 스택 영역이 높은 주소 -> 낮은 주소로 할당되고, 힙 영역이 낮은 주소 -> 높은 주소로  
   할당되기 때문에 자신의 영역이 상대의 영역을 침범하는 사태가 발생할 수 있음  
   이를 각각 스택 오버플로우, 힙 오버플로우라고 함  
   
   * 할당 속도 비교  
     - 스택은 컴파일 시 이미 할당된 공간을 사용함  
       + 스택에서 말하는 할당이란 이미 생성된 스택에 대해 포인터 위치만 바꿔주는  
         단순한 CPU Instruction을 말함  
   * 힙은 사용자가 따로 할당해서 사용하는 공간  
     - 힙에서의 할당이란 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등  
       다양한 요소를 고려하기 때문에 더 많은 CPU Instruction을 필요로 함  
       
  > 따라서 스택 할당 속도가 훨씬 빠르다!!!!!
       
      
    
